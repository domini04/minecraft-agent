# Agent State Definition

This document defines the LangGraph shared state structure. Every node (Guide Retriever, Planner, Executor, Replanner, Reflexion) reads from and writes to this state.

**Status**: Initial draft — will be updated as implementation reveals additional needs.

---

## State Structure

```python
class AgentState(TypedDict):
    goal: str                  # User's original request
    guide: dict                # Retrieved SOP (YAML loaded as dict)
    plan: list[dict]           # Ordered list of tool calls
    current_step: int          # Index of current step being executed
    step_results: list[dict]   # Results from each executed step
    retry_count: int           # Current retry count for active step
    bot_status: dict           # Health, hunger, position, inventory, surroundings
    errors: list[dict]         # Error history for Reflexion node
    result: str                # Final output message
```

---

## Field Descriptions

### `goal` — `str`
The user's original natural language request, verbatim.

**Set by**: Entry point (user input)
**Read by**: Guide Retriever (to match SOPs), Planner (to understand intent)

**Example**: `"Get me a stone pickaxe"`

---

### `guide` — `dict`
The SOP retrieved by the Guide Retriever node. Contains the YAML template loaded as a Python dict.

**Set by**: Node 1 (Guide Retriever)
**Read by**: Node 2 (Planner)

**Example**:
```python
{
    "name": "Stone Pickaxe",
    "tags": ["crafting", "tools", "pickaxe", "stone"],
    "requires": [
        {"item": "oak_log", "count": 3},
        {"item": "cobblestone", "count": 3}
    ],
    "steps": [
        {"action": "mine", "target": "oak_log", "count": 3},
        {"action": "craft", "item": "oak_planks", "count": 6},
        # ...
    ]
}
```

---

### `plan` — `list[dict]`
Ordered list of tool calls generated by the Planner. Each entry maps to a composite tool invocation.

**Set by**: Node 2 (Planner), Node 5 (Reflexion — may modify the plan)
**Read by**: Node 3 (Tool Executor), Node 4 (Replanner)

**Example**:
```python
[
    {"action": "mine", "params": {"target": "oak_log", "count": 3}},
    {"action": "craft", "params": {"item": "oak_planks", "count": 6}},
    {"action": "craft", "params": {"item": "stick", "count": 2}},
    {"action": "craft", "params": {"item": "crafting_table", "count": 1}},
    {"action": "craft", "params": {"item": "wooden_pickaxe", "count": 1}},
    {"action": "mine", "params": {"target": "stone", "count": 3}},
    {"action": "craft", "params": {"item": "stone_pickaxe", "count": 1}},
]
```

---

### `current_step` — `int`
Zero-based index of the step currently being executed from the `plan`.

**Set by**: Node 4 (Replanner — advances after success), reset to 0 by Node 2 (Planner)
**Read by**: Node 3 (Tool Executor), Node 4 (Replanner)

---

### `step_results` — `list[dict]`
Accumulated results from each executed step. Used for context in replanning and final output.

**Set by**: Node 3 (Tool Executor — appends after each execution)
**Read by**: Node 4 (Replanner), Node 5 (Reflexion)

**Example**:
```python
[
    {"step": 0, "action": "mine", "success": True, "data": {"collected": 3, "item": "oak_log"}},
    {"step": 1, "action": "craft", "success": True, "data": {"crafted": 6, "item": "oak_planks"}},
    {"step": 2, "action": "craft", "success": False, "error": "Missing item: stick requires oak_planks x2"},
]
```

---

### `retry_count` — `int`
Number of retry attempts for the current step. Resets to 0 when advancing to the next step.

**Set by**: Node 5 (Reflexion — increments), Node 4 (Replanner — resets on step advance)
**Read by**: Retry check conditional edge (routes to Reflexion or Fail based on count < 3)

**Max value**: 3 (after 3 failed retries, agent reports failure and stops)

---

### `bot_status` — `dict`
Current state of the Mineflayer bot. Refreshed by calling `get_bot_status()` before planning or after errors.

**Set by**: Node 3 (Tool Executor — updates after each action)
**Read by**: Node 2 (Planner — to adapt plan to current inventory), Node 5 (Reflexion — to understand failure context)

**Example**:
```python
{
    "health": 20,
    "food": 18,
    "position": {"x": 120.5, "y": 64.0, "z": -45.2},
    "inventory": [
        {"name": "oak_log", "count": 3},
        {"name": "oak_planks", "count": 2},
    ],
    "nearby_blocks": ["grass_block", "dirt", "oak_log", "stone"],
    "nearby_entities": [],
}
```

---

### `errors` — `list[dict]`
History of errors encountered during execution. Used by the Reflexion node to avoid repeating failed approaches.

**Set by**: Node 3 (Tool Executor — appends on failure)
**Read by**: Node 5 (Reflexion — analyzes patterns to suggest corrections)

**Example**:
```python
[
    {
        "step": 0,
        "action": "mine",
        "attempt": 1,
        "error": "No oak_log found within 50 blocks",
        "bot_position": {"x": 120.5, "y": 64.0, "z": -45.2},
    },
]
```

---

### `result` — `str`
Final output message displayed to the user upon task completion or failure.

**Set by**: End node (on success) or Fail node (on exhausted retries)
**Read by**: User interface (CLI/Streamlit)

**Example (success)**: `"Task complete: crafted 1 stone_pickaxe. Inventory now contains stone_pickaxe x1."`
**Example (failure)**: `"Task failed at step 'mine stone': No stone blocks found within search radius after 3 attempts."`

---

## Changelog

| Date | Change | Reason |
|------|--------|--------|
| Initial | Created with 9 fields | Blueprint clarification session |
